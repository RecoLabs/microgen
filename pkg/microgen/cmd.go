package microgen

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"path"
	"path/filepath"
	"plugin"
	"runtime"
	"strings"
	"time"

	"github.com/devimteam/microgen/gen"
	"github.com/devimteam/microgen/logger"
	lg "github.com/devimteam/microgen/logger"
	"github.com/pkg/errors"
	"github.com/vetcher/go-astra"
	"github.com/vetcher/go-astra/types"
)

var (
	flagDstDir  = flag.String("dst", ".", "Destiny path.")
	flagVerbose = flag.Int("v", logger.Common, "Sets microgen verbose level.")
	flagDebug   = flag.Bool("debug", false, "Print all microgen messages. Equivalent to -v=100.")
	flagConfig  = flag.String("cfg", "microgen.json", "")
	flagDry     = flag.Bool("dry", false, "Do everything except writing files.")
	flagInit    = flag.Bool("init", false, "")
)

func init() {
	if !flag.Parsed() {
		flag.Parse()
	}
}

const (
	Microgen          = "microgen"
	MicrogenVersion   = "1.0"
	DefaultFileHeader = `Code generated by microgen. DO NOT EDIT.`
)

func Exec() {
	var err error
	defer func() {
		if err != nil {
			lg.Logger.Logln(logger.Critical, "fatal:", err)
			os.Exit(1)
		}
		if err := recover(); err != nil {
			const size = 64 << 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			lg.Logger.Logln(logger.Critical, "panic:", err, "\n", string(buf))
			os.Exit(1)
		}
	}()
	begin := time.Now()
	defer func() {
		lg.Logger.Logln(logger.Info, "Duration:", time.Since(begin))
	}()
	if *flagVerbose < logger.Critical {
		*flagVerbose = logger.Critical
	}
	lg.Logger.Level = *flagVerbose
	if *flagDebug {
		lg.Logger.Level = logger.Debug
		lg.Logger.Logln(logger.Debug, "Debug logs mode in on")
	}
	lg.Logger.Logln(logger.Common, Microgen, MicrogenVersion)

	lg.Logger.Logln(logger.Detail, "Config:", *flagConfig)
	cfg, err := processConfig(*flagConfig)
	if err != nil {
		return
	}

	pkg, err := astra.GetPackage(".", astra.AllowAnyImportAliases,
		astra.IgnoreStructs, astra.IgnoreFunctions, astra.IgnoreConstants,
		astra.IgnoreMethods, astra.IgnoreTypes, astra.IgnoreVariables,
	)
	if err != nil {
		lg.Logger.Logln(0, "fatal:", err)
		os.Exit(1)
	}
	ii := findInterfaces(pkg)
	iface, err := selectInterface(ii, cfg.Interface)
	if err != nil {
		lg.Logger.Logln(logger.Detail, "All founded interfaces:")
		lg.Logger.Logln(logger.Detail, listInterfaces(pkg.Interfaces))
		return
	}
	if err = validateInterface(iface); err != nil {
		return
	}

	err = initPlugins(cfg.Plugins)
	if err != nil {
		return
	}

	source, err := os.Getwd()
	if err != nil {
		return
	}
	sourcePackage, err := gen.GetPkgPath(".", true)
	if err != nil {
		return
	}

	lg.Logger.Logln(logger.Debug, "Start generation")
	ctx := Context{
		Interface:           iface,
		Source:              source,
		SourcePackageName:   pkg.Name,
		SourcePackageImport: sourcePackage,
		FileHeader:          DefaultFileHeader,
		Files:               nil,
		AllowedMethods:      makeAllowedMethods(iface),
	}
	lg.Logger.Logln(logger.Debug, "Exec plugins")
	for _, pcfg := range cfg.Generate {
		fnErr := func() error {
			defer func() {
				if e := recover(); e != nil {
					err = errors.Errorf("recover panic from '%s' plugin. Message: %v", pcfg.Name, e)
				}
			}()
			p, ok := pluginsRepository[pcfg.Name]
			if !ok {
				return errors.Errorf("plugin '%s' not registered", pcfg.Name)
			}
			lg.Logger.Logln(logger.Debug, "run", "'"+pcfg.Name+"'", "plugin with args:", string(pcfg.Args))
			ctx, err = p.Generate(ctx, pcfg.Args)
			if err != nil {
				return errors.Wrapf(err, "plugin '%s' returns an error", pcfg.Name)
			}
			return nil
		}()
		if fnErr != nil {
			err = fnErr
			return
		}
	}
	if *flagDry {
		lg.Logger.Logln(logger.Debug, "dry execution: do not create files")
		return
	}
	lg.Logger.Logln(logger.Debug, "Write files")
	for _, f := range ctx.Files {
		lg.Logger.Logln(logger.Debug, "create", f.Path)
		tgtFile, e := makeDirsAndCreateFile(f.Path)
		if e != nil {
			err = errors.Wrapf(e, "plugin '%s': during creating '%s' file", f.Name, f.Path)
			return
		}
		defer tgtFile.Close()
		lg.Logger.Logln(logger.Debug, "write", f.Path)
		_, e = tgtFile.Write(f.Content)
		if e != nil {
			err = errors.Wrapf(e, "plugin '%s': during writing '%s' file", f.Name, f.Path)
			return
		}
	}
	lg.Logger.Logln(logger.Info, "Done")
}

const MkdirPermissions = 0777

func makeDirsAndCreateFile(p string) (*os.File, error) {
	outpath, err := filepath.Abs(p)
	if err != nil {
		return nil, errors.WithMessage(err, "unable to resolve path")
	}
	dir := path.Dir(outpath)

	_, err = os.Stat(dir)
	if os.IsNotExist(err) {
		err = os.MkdirAll(dir, MkdirPermissions)
		if err != nil {
			return nil, errors.Wrapf(err, "unable to create directory '%s'", outpath)
		}
	} else if err != nil {
		return nil, errors.WithMessage(err, "could not stat file")
	}

	tgtFile, err := os.Create(p)
	if err != nil {
		return nil, errors.WithMessage(err, "create file")
	}
	return tgtFile, nil
}

func makeAllowedMethods(iface *types.Interface) map[string]bool {
	m := make(map[string]bool)
	for _, fn := range iface.Methods {
		m[fn.Name] = !FetchTags(fn.Docs, "//"+Microgen).Has("-")
	}
	return m
}

func findInterfaces(file *types.File) []*types.Interface {
	var ifaces []*types.Interface
	for i := range file.Interfaces {
		if docsContainMicrogenTag(file.Interfaces[i].Docs) {
			ifaces = append(ifaces, &file.Interfaces[i])
		}
	}
	return ifaces
}

func listInterfaces(ii []types.Interface) string {
	var s string
	for _, i := range ii {
		s = s + fmt.Sprintf("\t%s(%d methods, %d embedded interfaces)\n", i.Name, len(i.Methods), len(i.Interfaces))
	}
	return s
}

func selectInterface(ii []*types.Interface, name string) (*types.Interface, error) {
	if name == "" {
		return nil, fmt.Errorf("%d interfaces founded, but 'interface' config parameter is empty. Add \"interface = InterfaceName\" to config file", len(ii))
	}
	for i := range ii {
		if ii[i].Name == name {
			return ii[i], nil
		}
	}
	return nil, fmt.Errorf("'%s' interface not found, but %d others are available", name, len(ii))
}

func docsContainMicrogenTag(strs []string) bool {
	for _, str := range strs {
		if strings.HasPrefix(str, "//"+Microgen) {
			return true
		}
	}
	return false
}

func processConfig(pathToConfig string) (*config, error) {
	file, err := os.Open(pathToConfig)
	if err != nil {
		return nil, errors.WithMessage(err, "open file")
	}
	var rawToml bytes.Buffer
	_, err = rawToml.ReadFrom(file)
	if err != nil {
		return nil, errors.WithMessage(err, "read from config")
	}
	var cfg config
	err = json.NewDecoder(&rawToml).Decode(&cfg)
	if err != nil {
		return nil, errors.WithMessage(err, "unmarshal config")
	}
	return &cfg, nil
}

func initPlugins(plugins []string) error {
	for i := range plugins {
		_, err := plugin.Open(plugins[i])
		if err != nil {
			return errors.Wrapf(err, "open plugin '%s'", plugins[i])
		}
	}
	return nil
}

func validateInterface(iface *types.Interface) error {
	var errs []error
	if len(iface.Methods) == 0 {
		errs = append(errs, fmt.Errorf("%s does not have any methods", iface.Name))
	}
	return composeErrors(errs...)
}

func composeErrors(errs ...error) error {
	if len(errs) > 0 {
		var strs []string
		for _, err := range errs {
			if err != nil {
				strs = append(strs, err.Error())
			}
		}
		if len(strs) == 1 {
			return fmt.Errorf(strs[0])
		}
		if len(strs) > 0 {
			return fmt.Errorf("many errors:\n%v", strings.Join(strs, "\n"))
		}
	}
	return nil
}
