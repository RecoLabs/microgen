package template

import (
	"fmt"
	"os"
	"path/filepath"

	. "github.com/dave/jennifer/jen"
	"github.com/devimteam/microgen/generator/write_strategy"
	"github.com/devimteam/microgen/util"
	"github.com/vetcher/godecl/types"
)

type stubInterfaceTemplate struct {
	Info *GenerationInfo

	alreadyRenderedMethods []string
	isStructExist          bool
	isConstructorExist     bool
}

func NewStubInterfaceTemplate(info *GenerationInfo) Template {
	return &stubInterfaceTemplate{
		Info: info,
	}
}

// Renders stub code for service, its methods and constructor, that implements service interface.
//
//		// Generated by "microgen" tool.
//		// Structure stringService implements StringService interface.
//		type stringService struct {
//		}
//
//		func NewStringService() StringService {
//			panic("constructor not provided")
//		}
//
//		func (s *stringService) Count(ctx context.Context, text string, symbol string) (count int, positions []int) {
//			panic("method not provided")
//		}
//
func (t *stubInterfaceTemplate) Render() write_strategy.Renderer {
	f := &Statement{}

	if !t.isStructExist {
		f.Comment(`Generated by "microgen" tool.`).Line().
			Commentf(`Struct %s implements %s interface.`, util.ToLower(t.Info.Iface.Name), t.Info.Iface.Name).Line().
			Type().Id(util.ToLower(t.Info.Iface.Name)).Struct(Line()).Line()
	}

	if !t.isConstructorExist {
		f.Func().Id(constructorName(t.Info.Iface)).Params().Id(t.Info.Iface.Name).Block(
			Panic(Lit("constructor not provided")).Comment("// TODO: provide constructor"),
		).Line()
	}

	for _, signature := range t.Info.Iface.Methods {
		if !util.IsInStringSlice(signature.Name, t.alreadyRenderedMethods) {
			f.Line().Add(methodDefinition(util.ToLower(t.Info.Iface.Name), signature)).Block(
				Panic(Lit("method not provided")).Comment("// TODO: provide method"),
			).Line()
		}
	}
	return f
}

func (stubInterfaceTemplate) DefaultPath() string {
	return "."
}

func (t *stubInterfaceTemplate) Prepare() error {
	if err := util.StatFile(t.Info.SourceFilePath, t.DefaultPath()); os.IsNotExist(err) {
		fmt.Println("warning:", err)
		return nil
	}
	file, err := util.ParseFile(filepath.Join(t.Info.SourceFilePath, t.DefaultPath()))
	if err != nil {
		return err
	}

	// Remove already provided service methods
	for i := range file.Methods {
		name := types.TypeName(file.Methods[i].Receiver.Type)
		if name != nil && *name == util.ToLowerFirst(t.Info.Iface.Name) && types.TypeImport(file.Methods[i].Receiver.Type) == nil {
			t.alreadyRenderedMethods = append(t.alreadyRenderedMethods, file.Methods[i].Name)
		}
	}

	// Remove already provided service structure
	for i := range file.Structures {
		if file.Structures[i].Name == util.ToLowerFirst(t.Info.Iface.Name) {
			t.isStructExist = true
			break
		}
	}

	// Remove already provided service constructor
	for i := range file.Functions {
		if file.Functions[i].Name == constructorName(t.Info.Iface) {
			t.isConstructorExist = true
			break
		}
	}

	return nil
}

func (t *stubInterfaceTemplate) ChooseStrategy() (write_strategy.Strategy, error) {
	return write_strategy.NewAppendToFileStrategy(t.Info.SourceFilePath, t.DefaultPath()), nil
}

func constructorName(p *types.Interface) string {
	return "New" + p.Name
}
