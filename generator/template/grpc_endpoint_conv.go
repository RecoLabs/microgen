package template

import (
	"fmt"
	"path/filepath"

	. "github.com/dave/jennifer/jen"
	"github.com/devimteam/microgen/generator/write_strategy"
	"github.com/devimteam/microgen/util"
	"github.com/vetcher/godecl/types"
)

var (
	defaultProtoTypes = []string{"string", "bool", "byte", "int64", "uint64", "float64", "int32", "uint32", "float32"}
	goToProtoTypesMap = map[string]string{
		"uint": "uint64",
		"int":  "int64",
	}
	defaultGolangTypes = []string{"string", "bool", "int", "uint", "byte", "int64", "uint64", "float64", "int32", "uint32", "float32"}
)

type gRPCEndpointConverterTemplate struct {
	Info             *GenerationInfo
	requestEncoders  []*types.Function
	requestDecoders  []*types.Function
	responseEncoders []*types.Function
	responseDecoders []*types.Function
	state            WriteStrategyState
}

func NewGRPCEndpointConverterTemplate(info *GenerationInfo) Template {
	return &gRPCEndpointConverterTemplate{
		Info: info,
	}
}

func requestDecodeName(f *types.Function) string {
	return "Decode" + f.Name + "Request"
}

func responseDecodeName(f *types.Function) string {
	return "Decode" + f.Name + "Response"
}

func requestEncodeName(f *types.Function) string {
	return "Encode" + f.Name + "Request"
}

func responseEncodeName(f *types.Function) string {
	return "Encode" + f.Name + "Response"
}

// Renders converter file.
//
//		// This file was automatically generated by "microgen" utility.
//		// Please, do not edit.
//		package protobuf
//
//		import (
//			context "context"
//			svc "github.com/devimteam/microgen/example/svc"
//			stringsvc "gitlab.devim.team/protobuf/stringsvc"
//		)
//
//		func EncodeCountRequest(_ context.Context, request interface{}) (interface{}, error) {
//			req := request.(*svc.CountRequest)
//			return &stringsvc.CountRequest{
//				Symbol: req.Symbol,
//				Text:   req.Text,
//			}, nil
//		}
//
//		func EncodeCountResponse(_ context.Context, response interface{}) (interface{}, error) {
//			resp := response.(*svc.CountResponse)
//			respPositions, err := IntListToProto(resp.Positions)
//			if err != nil {
//				return nil, err
//			}
//			return &stringsvc.CountResponse{
//				Count:     int64(resp.Count),
//				Positions: respPositions,
//			}, nil
//		}
//
//		func DecodeCountRequest(_ context.Context, request interface{}) (interface{}, error) {
//			req := request.(*stringsvc.CountRequest)
//			return &svc.CountRequest{
//				Symbol: string(req.Symbol),
//				Text:   string(req.Text),
//			}, nil
//		}
//
//		func DecodeCountResponse(_ context.Context, response interface{}) (interface{}, error) {
//			resp := response.(*stringsvc.CountResponse)
//			respPositions, err := ProtoToIntList(resp.Positions)
//			if err != nil {
//				return nil, err
//			}
//			return &svc.CountResponse{
//				Count:     int(resp.Count),
//				Positions: respPositions,
//			}, nil
//		}
//
func (t *gRPCEndpointConverterTemplate) Render() write_strategy.Renderer {
	f := &Statement{}

	for _, signature := range t.requestEncoders {
		f.Line().Add(t.encodeRequest(signature))
	}
	for _, signature := range t.responseEncoders {
		f.Line().Add(t.encodeResponse(signature))
	}
	for _, signature := range t.requestDecoders {
		f.Line().Add(t.decodeRequest(signature))
	}
	for _, signature := range t.responseDecoders {
		f.Line().Add(t.decodeResponse(signature))
	}

	if t.state == AppendStrat {
		return f
	}

	file := NewFile("protobuf")
	file.PackageComment(t.Info.FileHeader)
	file.PackageComment(`Please, do not change functions names!`)
	file.Add(f)

	return file
}

const (
	_pointer   = "Ptr"
	_list      = "List"
	_slice     = "List"
	_map       = "Map"
	_interface = "Interface"
	_toProto   = "ToProto"
	_protoTo   = "ProtoTo"
	_ellipsis  = "El"
)

// Returns FieldTypeToProto.
func typeToProto(field types.Type, depth int) string {
	methodName := ""
Loop:
	for field != nil {
		switch f := field.(type) {
		case types.TImport:
			if f.Import != nil {
				methodName += util.ToUpperFirst(f.Import.Name)
			}
			field = f.Next
		case types.TName:
			methodName += util.ToUpperFirst(f.TypeName)
			field = nil
		case types.TArray:
			if f.IsSlice {
				methodName += _slice
			} else if f.ArrayLen > 0 {
				methodName += _list
			}
			field = f.Next
		case types.TMap:
			methodName += _map + typeToProto(f.Key, 1) + typeToProto(f.Value, 1)
			field = nil
		case types.TPointer:
			if f.NumberOfPointers > 1 {
				methodName += fmt.Sprintf("%sX%d", _pointer, f.NumberOfPointers)
			} else {
				methodName += _pointer
			}
			field = f.Next
		case types.TInterface:
			methodName += _interface
			field = nil
		case types.TEllipsis:
			methodName += _ellipsis
			field = f.Next
		default:
			break Loop
		}
	}
	if depth == 0 {
		methodName += _toProto
	}
	return methodName
}

// Returns ProtoToFieldType.
func protoToType(field types.Type, depth int) string {
	methodName := ""
	if depth == 0 {
		methodName += _protoTo
	}
Loop:
	for field != nil {
		switch f := field.(type) {
		case types.TImport:
			if f.Import != nil {
				methodName += util.ToUpperFirst(f.Import.Name)
			}
			field = f.Next
		case types.TName:
			methodName += util.ToUpperFirst(f.TypeName)
			field = nil
		case types.TArray:
			if f.IsSlice {
				methodName += _slice
			} else if f.ArrayLen > 0 {
				methodName += _list
			}
			field = f.Next
		case types.TMap:
			methodName += _map + typeToProto(f.Key, 1) + typeToProto(f.Value, 1)
			field = nil
		case types.TPointer:
			if f.NumberOfPointers > 1 {
				methodName += fmt.Sprintf("%sX%d", _pointer, f.NumberOfPointers)
			} else {
				methodName += _pointer
			}
			field = f.Next
		case types.TInterface:
			methodName += _interface
			field = nil
		case types.TEllipsis:
			methodName += _ellipsis
			field = f.Next
		default:
			break Loop
		}
	}
	return methodName
}

func (gRPCEndpointConverterTemplate) DefaultPath() string {
	return "./transport/converter/protobuf/endpoint_converters.go"
}

func (t *gRPCEndpointConverterTemplate) Prepare() error {
	if t.Info.ProtobufPackage == "" {
		return ProtobufEmptyError
	}
	for _, fn := range t.Info.Iface.Methods {
		t.requestDecoders = append(t.requestDecoders, fn)
		t.requestEncoders = append(t.requestEncoders, fn)
		t.responseDecoders = append(t.responseDecoders, fn)
		t.responseEncoders = append(t.responseEncoders, fn)
	}
	return nil
}

func (t *gRPCEndpointConverterTemplate) ChooseStrategy() (write_strategy.Strategy, error) {
	if err := util.StatFile(t.Info.AbsOutPath, t.DefaultPath()); t.Info.Force || err != nil {
		t.state = FileStrat
		return write_strategy.NewCreateFileStrategy(t.Info.AbsOutPath, t.DefaultPath()), nil
	}
	file, err := util.ParseFile(filepath.Join(t.Info.AbsOutPath, t.DefaultPath()))
	if err != nil {
		return nil, err
	}

	removeAlreadyExistingFunctions(file.Functions, &t.requestEncoders, requestEncodeName)
	removeAlreadyExistingFunctions(file.Functions, &t.requestDecoders, requestDecodeName)
	removeAlreadyExistingFunctions(file.Functions, &t.responseEncoders, responseEncodeName)
	removeAlreadyExistingFunctions(file.Functions, &t.responseDecoders, responseDecodeName)

	t.state = AppendStrat
	return write_strategy.NewAppendToFileStrategy(t.Info.AbsOutPath, t.DefaultPath()), nil
}

func isPointer(p types.Type) bool {
	pp, ok := p.(types.TPointer)
	return ok && pp.NumberOfPointers == 1
}

// Renders type conversion (if need) to default protobuf types.
//		req.Symbol
// or
//		int(resp.Count)
// or
//		structNamePositions
// based on field type
// Second result means can field converts to default protobuf type.
func golangTypeToProto(structName string, field *types.Variable) (*Statement, bool) {
	if types.IsArray(field.Type) || isPointer(field.Type) {
		return Id(structName + util.ToUpperFirst(field.Name)), false
	} else if isDefaultProtoField(field) {
		return Id(structName).Dot(util.ToUpperFirst(field.Name)), true
	}
	name := types.TypeName(field.Type)
	if name == nil {
		return Id(structName + util.ToUpperFirst(field.Name)), false
	}
	if newType, ok := goToProtoTypesMap[*name]; ok {
		var newField types.Type
		newField = types.TName{
			TypeName: newType,
		}
		if imp := types.TypeImport(field.Type); imp != nil {
			newField = types.TImport{
				Next:   newField,
				Import: imp,
			}
		}
		return fieldType(newField, false).Call(Id(structName).Dot(util.ToUpperFirst(field.Name))), true
	}
	return Id(structName + util.ToUpperFirst(field.Name)), false
}

// Renders type conversion to default golang types.
// 		int(resp.Count)
// or
// 		structNamePositions
// based on field type
// Second result means can field converts to golang type.
func protoTypeToGolang(structName string, field *types.Variable) (*Statement, bool) {
	if types.IsArray(field.Type) || isPointer(field.Type) {
		return Id(structName + util.ToUpperFirst(field.Name)), false
	} else if isDefaultGolangField(field) {
		return fieldType(field.Type, false).Call(Id(structName).Dot(util.ToUpperFirst(field.Name))), true
	}
	return Id(structName + util.ToUpperFirst(field.Name)), false
}

func isDefaultProtoField(field *types.Variable) bool {
	name := types.TypeName(field.Type)
	return name != nil && util.IsInStringSlice(*name, defaultProtoTypes)
}

func isDefaultGolangField(field *types.Variable) bool {
	name := types.TypeName(field.Type)
	return name != nil && util.IsInStringSlice(*name, defaultGolangTypes)
}

// Render custom type converting and error checking
//
//		structNamePositions, err := ProtoToIntList(structName.Positions)
//		if err != nil {
//			return nil, err
//		}
//
func (t *gRPCEndpointConverterTemplate) convertCustomType(structName, converterName string, field *types.Variable) *Statement {
	return List(Id(structName+util.ToUpperFirst(field.Name)), Err()).
		Op(":=").
		Add(
			Id(converterName).
				Call(Id(structName).
					Dot(util.ToUpperFirst(field.Name))),
		).
		Line().If(Err().Op("!=").Nil()).Block(
		Return().List(Nil(), Err()),
	)
}

// Renders function for encoding request, golang type converts to proto type.
//
//		func EncodeCountRequest(_ context.Context, request interface{}) (interface{}, error) {
//			req := request.(*svc.CountRequest)
//			return &stringsvc.CountRequest{
//				Symbol: req.Symbol,
//				Text:   req.Text,
//			}, nil
//		}
//
func (t *gRPCEndpointConverterTemplate) encodeRequest(signature *types.Function) *Statement {
	methodParams := RemoveContextIfFirst(signature.Args)
	fullName := "request"
	shortName := "req"
	return Line().Func().Id(requestEncodeName(signature)).Params(Op("_").Qual(PackagePathContext, "Context"), Id(fullName).Interface()).Params(Interface(), Error()).BlockFunc(
		func(group *Group) {
			if len(methodParams) == 1 {
				sp := specialEndpointConverterToProto(methodParams[0], fullName, shortName)
				if sp != nil {
					group.Add(sp)
					return
				}
			}
			if len(methodParams) > 0 {
				group.Id(shortName).Op(":=").Id(fullName).Assert(Op("*").Qual(t.Info.ServiceImportPath, requestStructName(signature)))
				group.If(Id(shortName).Op("==").Nil()).Block(
					Return(Nil(), Qual(PackagePathErrors, "New").Call(Lit("nil "+requestStructName(signature)))),
				)
				for _, field := range methodParams {
					if _, ok := golangTypeToProto("", &field); !ok {
						group.Add(t.convertCustomType(shortName, typeToProto(field.Type, 0), &field))
					}
				}
			}
			group.Return().List(t.grpcEndpointConvReturn(signature, methodParams, requestStructName, shortName, golangTypeToProto, t.Info.ProtobufPackage), Nil())
		},
	).Line()
}

//PackagePathEmptyProtobuf
func (t *gRPCEndpointConverterTemplate) grpcEndpointConvReturn(fn *types.Function,
	methodParams []types.Variable,
	strNameFn func(*types.Function) string,
	rec string,
	typeToProtoFn func(string, *types.Variable) (*Statement, bool),
	pkg string,
) *Statement {
	if len(methodParams) == 0 {
		return Op("&").Qual(PackagePathEmptyProtobuf, "Empty").Values()
	}
	return Op("&").Qual(pkg, strNameFn(fn)).Values(DictFunc(func(dict Dict) {
		for _, field := range methodParams {
			req, _ := typeToProtoFn(rec, &field)
			dict[structFieldName(&field)] = Line().Add(req)
		}
	}))
}

// Renders function for encoding response, golang type converts to proto type.
//
//		func EncodeCountResponse(_ context.Context, response interface{}) (interface{}, error) {
//			resp := response.(*svc.CountResponse)
//			respPositions, err := IntListToProto(resp.Positions)
//			if err != nil {
//				return nil, err
//			}
//			return &stringsvc.CountResponse{
//				Count:     int64(resp.Count),
//				Positions: respPositions,
//			}, nil
//		}
//
func (t *gRPCEndpointConverterTemplate) encodeResponse(signature *types.Function) *Statement {
	methodResults := removeErrorIfLast(signature.Results)
	fullName := "response"
	shortName := "resp"
	return Line().Func().Id(responseEncodeName(signature)).Call(Op("_").Qual(PackagePathContext, "Context"), Id(fullName).Interface()).Params(Interface(), Error()).BlockFunc(
		func(group *Group) {
			if len(methodResults) == 1 {
				sp := specialEndpointConverterToProto(methodResults[0], fullName, shortName)
				if sp != nil {
					group.Add(sp)
					return
				}
			}
			if len(methodResults) > 0 {
				group.Id(shortName).Op(":=").Id(fullName).Assert(Op("*").Qual(t.Info.ServiceImportPath, responseStructName(signature)))
				group.If(Id(shortName).Op("==").Nil()).Block(
					Return(Nil(), Qual(PackagePathErrors, "New").Call(Lit("nil "+responseStructName(signature)))),
				)
				for _, field := range methodResults {
					if _, ok := golangTypeToProto("", &field); !ok {
						group.Add(t.convertCustomType(shortName, typeToProto(field.Type, 0), &field))
					}
				}
			}
			group.Return().List(t.grpcEndpointConvReturn(signature, methodResults, responseStructName, shortName, golangTypeToProto, t.Info.ProtobufPackage), Nil())
		},
	).Line()
}

// Renders function for decoding request, proto type converts to golang type.
//
//		func DecodeCountRequest(_ context.Context, request interface{}) (interface{}, error) {
//			req := request.(*stringsvc.CountRequest)
//			return &svc.CountRequest{
//				Symbol: string(req.Symbol),
//				Text:   string(req.Text),
//			}, nil
//		}
//
func (t *gRPCEndpointConverterTemplate) decodeRequest(signature *types.Function) *Statement {
	methodParams := RemoveContextIfFirst(signature.Args)
	fullName := "request"
	shortName := "req"
	return Line().Func().Id(requestDecodeName(signature)).Call(Op("_").Qual(PackagePathContext, "Context"), Id(fullName).Interface()).Params(Interface(), Error()).BlockFunc(
		func(group *Group) {
			if len(methodParams) == 1 {
				sp := specialEndpointConverterFromProto(methodParams[0], fullName, shortName)
				if sp != nil {
					group.Add(sp)
					return
				}
			}
			if len(methodParams) > 0 {
				group.Id(shortName).Op(":=").Id(fullName).Assert(Op("*").Qual(t.Info.ProtobufPackage, requestStructName(signature)))
				group.If(Id(shortName).Op("==").Nil()).Block(
					Return(Nil(), Qual(PackagePathErrors, "New").Call(Lit("nil "+requestStructName(signature)))),
				)
				for _, field := range methodParams {
					if _, ok := protoTypeToGolang("", &field); !ok {
						group.Add(t.convertCustomType(shortName, protoToType(field.Type, 0), &field))
					}
				}
			}
			group.Return().List(t.grpcEndpointConvReturn(signature, methodParams, requestStructName, shortName, protoTypeToGolang, t.Info.ServiceImportPath), Nil())
		},
	).Line()
}

// Renders function for decoding response, proto type converts to golang type.
//
//		func DecodeCountResponse(_ context.Context, response interface{}) (interface{}, error) {
//			resp := response.(*stringsvc.CountResponse)
//			respPositions, err := ProtoToIntList(resp.Positions)
//			if err != nil {
//				return nil, err
//			}
//			return &svc.CountResponse{
//				Count:     int(resp.Count),
//				Positions: respPositions,
//			}, nil
//		}
//
func (t *gRPCEndpointConverterTemplate) decodeResponse(signature *types.Function) *Statement {
	methodResults := removeErrorIfLast(signature.Results)
	fullName := "response"
	shortName := "resp"
	return Line().Func().Id(responseDecodeName(signature)).Call(Op("_").Qual(PackagePathContext, "Context"), Id(fullName).Interface()).Params(Interface(), Error()).BlockFunc(
		func(group *Group) {
			if len(methodResults) == 1 {
				sp := specialEndpointConverterFromProto(methodResults[0], fullName, shortName)
				if sp != nil {
					group.Add(sp)
					return
				}
			}
			if len(methodResults) > 0 {
				group.Id(shortName).Op(":=").Id(fullName).Assert(Op("*").Qual(t.Info.ProtobufPackage, responseStructName(signature)))
				group.If(Id(shortName).Op("==").Nil()).Block(
					Return(Nil(), Qual(PackagePathErrors, "New").Call(Lit("nil "+responseStructName(signature)))),
				)
				for _, field := range methodResults {
					if _, ok := protoTypeToGolang("", &field); !ok {
						group.Add(t.convertCustomType(shortName, protoToType(field.Type, 0), &field))
					}
				}
			}
			group.Return().List(t.grpcEndpointConvReturn(signature, methodResults, responseStructName, shortName, protoTypeToGolang, t.Info.ServiceImportPath), Nil())
		},
	).Line()
}

func specialEndpointConverterToProto(v types.Variable,
	//fn *types.Function,
	//strNameFn func(*types.Function) string,
	//pkg string,
	fullName string,
	shortName string,
	//typeToProtoFn func(string, *types.Variable) (*Statement, bool),
) *Statement {
	name := types.TypeName(v.Type)
	imp := types.TypeImport(v.Type)
	// *string -> *wrappers.StringValue
	if name != nil && *name == "string" && imp == nil && v.Type.TypeOf() == types.T_Pointer {
		sp := Op("*").Id("string")
		s := Id(shortName).Op(":=").Id(fullName).Assert(sp)
		s.Line().If(Id(shortName).Op("==").Nil()).Block(
			Return(Nil(), Nil()),
		)
		s.Line().Return(Op("&").Qual(GolangProtobufWrappers, "StringValue").Values(Dict{Id("Value"): Op("*").Id(shortName)}), Nil())
		return s
	}
	return nil
}

func specialEndpointConverterFromProto(v types.Variable,
	//fn *types.Function,
	//strNameFn func(*types.Function) string,
	//pkg string,
	fullName string,
	shortName string,
	//typeToProtoFn func(string, *types.Variable) (*Statement, bool),
) *Statement {
	name := types.TypeName(v.Type)
	imp := types.TypeImport(v.Type)
	// *string <- *wrappers.StringValue
	if name != nil && *name == "string" && imp == nil && v.Type.TypeOf() == types.T_Pointer {
		sp := Op("*").Qual(GolangProtobufWrappers, "StringValue")
		s := Id(shortName).Op(":=").Id(fullName).Assert(sp)
		s.Line().If(Id(shortName).Op("==").Nil()).Block(
			Return(Nil(), Nil()),
		)
		s.Line().Return(Op("&").Id(shortName).Dot("Value"), Nil())
		return s
	}
	return nil
}
