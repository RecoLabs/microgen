package template

import (
	. "github.com/dave/jennifer/jen"
	"github.com/devimteam/microgen/generator/write_strategy"
	"github.com/devimteam/microgen/util"
	"github.com/vetcher/go-astra/types"
)

type endpointsTemplate struct {
	Info    *GenerationInfo
	grpc    bool
	tracing bool
}

func NewEndpointsTemplate(info *GenerationInfo) Template {
	return &endpointsTemplate{
		Info: info,
	}
}

func endpointStructName(str string) string {
	return str + "Endpoint"
}

// Renders endpoints file.
//
//		// This file was automatically generated by "microgen" utility.
//		// DO NOT EDIT.
//		package stringsvc
//
//		import (
//			context "context"
//			endpoint "github.com/go-kit/kit/endpoint"
//		)
//
//		type Endpoints struct {
//			CountEndpoint endpoint.Endpoint
//		}
//
//		func (e *Endpoints) Count(ctx context.Context, text string, symbol string) (count int, positions []int) {
//			req := CountRequest{
//				Symbol: symbol,
//				Text:   text,
//			}
//			resp, err := e.CountEndpoint(ctx, &req)
//			if err != nil {
//				return
//			}
//			return resp.(*CountResponse).Count, resp.(*CountResponse).Positions
//		}
//
//		func CountEndpoint(svc StringService) endpoint.Endpoint {
//			return func(ctx context.Context, request interface{}) (interface{}, error) {
//				req := request.(*CountRequest)
//				count, positions := svc.Count(ctx, req.Text, req.Symbol)
//				return &CountResponse{
//					Count:     count,
//					Positions: positions,
//				}, nil
//			}
//		}
//
func (t *endpointsTemplate) Render() write_strategy.Renderer {
	f := NewFile("endpoints")
	f.PackageComment(t.Info.FileHeader)

	f.Add(t.allEndpoints()).Line()
	f.Type().Id("Endpoints").StructFunc(func(g *Group) {
		for _, signature := range t.Info.Iface.Methods {
			g.Id(endpointStructName(signature.Name)).Qual(PackagePathGoKitEndpoint, "Endpoint")
		}
	}).Line()
	for _, signature := range t.Info.Iface.Methods {
		f.Add(t.serviceEndpointMethod(signature)).Line().Line()
	}
	f.Line()
	for _, signature := range t.Info.Iface.Methods {
		f.Add(createEndpoint(signature, t.Info)).Line().Line()
	}

	return f
}

func (endpointsTemplate) DefaultPath() string {
	return filenameBuilder(PathEndpoints, "endpoints")
}

func (t *endpointsTemplate) Prepare() error {
	tags := util.FetchTags(t.Info.Iface.Docs, TagMark+MicrogenMainTag)
	for _, tag := range tags {
		switch tag {
		case GrpcTag, GrpcServerTag, GrpcClientTag:
			t.grpc = true
		case TracingTag:
			t.tracing = true
		}
	}
	return nil
}

func (t *endpointsTemplate) ChooseStrategy() (write_strategy.Strategy, error) {
	return write_strategy.NewCreateFileStrategy(t.Info.AbsOutputFilePath, t.DefaultPath()), nil
}

// Render full endpoints method.
//
//		func (e *Endpoints) Count(ctx context.Context, text string, symbol string) (count int, positions []int) {
//			req := CountRequest{
//				Symbol: symbol,
//				Text:   text,
//			}
//			resp, err := e.CountEndpoint(ctx, &req)
//			if err != nil {
//				return
//			}
//			return resp.(*CountResponse).Count, resp.(*CountResponse).Positions
//		}
//
func (t *endpointsTemplate) serviceEndpointMethod(signature *types.Function) *Statement {
	normal := normalizeFunction(signature)
	return methodDefinition("Endpoints", &normal.Function).
		BlockFunc(t.serviceEndpointMethodBody(signature, &normal.Function))
}

// Render interface method body.
//
//		endpointCountRequest := CountRequest{
//			Symbol: symbol,
//			Text:   text,
//		}
//		endpointCountResponse, err := E.CountEndpoint(ctx, &endpointCountRequest)
//		if err != nil {
//			return
//		}
//		return endpointCountResponse.(*CountResponse).Count, endpointCountResponse.(*CountResponse).Positions, err
//
func (t *endpointsTemplate) serviceEndpointMethodBody(fn *types.Function, normal *types.Function) func(g *Group) {
	reqName := "request"
	respName := "response"
	return func(g *Group) {
		g.Id(reqName).Op(":=").Id(requestStructName(fn)).Values(dictByNormalVariables(RemoveContextIfFirst(fn.Args), RemoveContextIfFirst(normal.Args)))
		g.Add(endpointResponse(respName, normal)).Id(util.LastUpperOrFirst("Endpoint")).Dot(endpointStructName(fn.Name)).Call(Id(firstArgName(normal)), Op("&").Id(reqName))
		g.If(Id(nameOfLastResultError(normal)).Op("!=").Nil().BlockFunc(func(ifg *Group) {
			if t.grpc {
				ifg.Add(checkGRPCError(normal))
			}
			ifg.Return()
		}))
		g.ReturnFunc(func(group *Group) {
			for _, field := range removeErrorIfLast(fn.Results) {
				group.Id(respName).Assert(Op("*").Id(responseStructName(fn))).Op(".").Add(structFieldName(&field))
			}
			group.Id(nameOfLastResultError(normal))
		})
	}
}

func checkGRPCError(fn *types.Function) *Statement {
	s := &Statement{}
	s.If(List(Id("e"), Id("ok")).Op(":=").Qual(PackagePathGoogleGRPCStatus, "FromError").Call(Id(nameOfLastResultError(fn))),
		Id("ok").Op("||").
			Id("e").Dot("Code").Call().Op("==").Qual(PackagePathGoogleGRPCCodes, "Internal").Op("||").
			Id("e").Dot("Code").Call().Op("==").Qual(PackagePathGoogleGRPCCodes, "Unknown"),
	).Block(
		Id(nameOfLastResultError(fn)).Op("=").Qual("errors", "New").Call(Id("e").Dot("Message").Call()),
	)
	return s
}

// Helper func for `serviceEndpointMethodBody`
func endpointResponse(respName string, fn *types.Function) *Statement {
	if len(removeErrorIfLast(fn.Results)) > 0 {
		return List(Id(respName), Id(nameOfLastResultError(fn))).Op(":=")
	}
	return List(Id("_"), Id(nameOfLastResultError(fn))).Op("=")
}

// For custom ctx in service interface (e.g. context or ctxxx).
func firstArgName(signature *types.Function) string {
	return util.ToLowerFirst(signature.Args[0].Name)
}

// Render new Endpoint body.
//
//		return func(ctx context.Context, request interface{}) (interface{}, error) {
//			req := request.(*CountRequest)
//			count, positions := svc.Count(ctx, req.Text, req.Symbol)
//			return &CountResponse{
//				Count:     count,
//				Positions: positions,
//			}, nil
//		}
//
func createEndpointBody(signature *normalizedFunction) *Statement {
	return Return(Func().Params(
		Id(firstArgName(&signature.Function)).Qual("context", "Context"),
		Id("request").Interface(),
	).Params(
		Interface(),
		Error(),
	).BlockFunc(func(g *Group) {
		methodParams := RemoveContextIfFirst(signature.parent.Args)
		if len(methodParams) > 0 {
			g.Id("req").Op(":=").Id("request").Assert(Op("*").Id(requestStructName(signature.parent)))
		}

		g.Add(paramNames(signature.Results).
			Op(":=").
			Id("svc").
			Dot(signature.Name).
			CallFunc(func(g *Group) {
				g.Add(Id(firstArgName(&signature.Function)))
				for _, field := range methodParams {
					v := Dot(util.ToUpperFirst(field.Name))
					if types.IsEllipsis(field.Type) {
						v.Op("...")
					}
					g.Add(Id("req").Add(v))
				}
			}))

		g.Return(
			Op("&").Id(responseStructName(signature.parent)).Values(dictByNormalVariables(
				removeErrorIfLast(signature.parent.Results),
				removeErrorIfLast(signature.Results),
			)),
			Id(nameOfLastResultError(&signature.Function)),
		)
	}))
}

// Render full new Endpoint function.
//
//		func CountEndpoint(svc StringService) endpoint.Endpoint {
//			return func(ctx context.Context, request interface{}) (interface{}, error) {
//				req := request.(*CountRequest)
//				count, positions := svc.Count(ctx, req.Text, req.Symbol)
//				return &CountResponse{
//					Count:     count,
//					Positions: positions,
//				}, nil
//			}
//		}
//
func createEndpoint(signature *types.Function, info *GenerationInfo) *Statement {
	normal := normalizeFunction(signature)
	return Func().
		Id(endpointStructName(signature.Name)).Params(Id("svc").Id(info.Iface.Name)).Params(Qual(PackagePathGoKitEndpoint, "Endpoint")).
		Block(createEndpointBody(normal))
}

func endpointExchange(base string, fn *types.Function) string {
	return "endpoint" + util.ToUpperFirst(fn.Name) + util.ToUpperFirst(base)
}

func (t *endpointsTemplate) allEndpoints() *Statement {
	s := &Statement{}
	s.Func().Id("AllEndpoints").Call(t.allEndpointsArguments()).Op("*").Id("Endpoints").BlockFunc(func(g *Group) {
		g.Return(Op("&").Id("Endpoints").Values(DictFunc(func(d Dict) {
			for _, signature := range t.Info.Iface.Methods {
				d[Id(endpointStructName(signature.Name))] = t.setupEndpointWithMiddlewares(signature)
			}
		})))
	})
	return s
}

func (t *endpointsTemplate) allEndpointsArguments() *Statement {
	s := &Statement{}
	s.Id("service").Id(t.Info.Iface.Name)
	if t.tracing {
		s.Op(",").Id("tracer").Qual(PackagePathOpenTracingGo, "Tracer")
	}
	return s
}

func (t *endpointsTemplate) setupEndpointWithMiddlewares(fn *types.Function) *Statement {
	s := &Statement{}
	if t.tracing {
		s.Qual(PackagePathGoKitTracing, "TraceServer").Call(Id("tracer"), Lit(fn.Name))
		s.Op("(")
		defer s.Op(")")
	}
	s.Id(endpointStructName(fn.Name)).Params(Id("service"))
	return s
}
