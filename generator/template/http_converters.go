package template

import (
	"path/filepath"

	. "github.com/dave/jennifer/jen"
	"github.com/devimteam/microgen/generator/write_strategy"
	"github.com/devimteam/microgen/util"
	"github.com/vetcher/godecl/types"
)

const (
	commonResponseEncoderName = "CommonHTTPResponseEncoder"
	commonRequestEncoderName  = "CommonHTTPRequestEncoder"
)

type httpConverterTemplate struct {
	Info                         *GenerationInfo
	encodersRequest              []*types.Function
	decodersRequest              []*types.Function
	encodersResponse             []*types.Function
	decodersResponse             []*types.Function
	state                        WriteStrategyState
	isCommonEncoderRequestExist  bool
	isCommonEncoderResponseExist bool
}

func NewHttpConverterTemplate(info *GenerationInfo) Template {
	return &httpConverterTemplate{
		Info: info,
	}
}

func (t *httpConverterTemplate) DefaultPath() string {
	return "./transport/converter/http/exchange_converters.go"
}

func (t *httpConverterTemplate) ChooseStrategy() (write_strategy.Strategy, error) {
	if err := util.StatFile(t.Info.AbsOutPath, t.DefaultPath()); t.Info.Force || err != nil {
		t.state = FileStrat
		return write_strategy.NewCreateFileStrategy(t.Info.AbsOutPath, t.DefaultPath()), nil
	}
	file, err := util.ParseFile(filepath.Join(t.Info.AbsOutPath, t.DefaultPath()))
	if err != nil {
		return nil, err
	}

	removeAlreadyExistingFunctions(file.Functions, &t.encodersRequest, httpEncodeRequestName)
	removeAlreadyExistingFunctions(file.Functions, &t.decodersRequest, httpDecodeRequestName)
	removeAlreadyExistingFunctions(file.Functions, &t.encodersResponse, httpEncodeResponseName)
	removeAlreadyExistingFunctions(file.Functions, &t.decodersResponse, httpDecodeResponseName)

	for i := range file.Functions {
		if file.Functions[i].Name == commonResponseEncoderName {
			t.isCommonEncoderResponseExist = true
			continue
		}
		if file.Functions[i].Name == commonRequestEncoderName {
			t.isCommonEncoderRequestExist = true
			continue
		}
		if t.isCommonEncoderRequestExist && t.isCommonEncoderResponseExist {
			break
		}
	}

	t.state = AppendStrat
	return write_strategy.NewAppendToFileStrategy(t.Info.AbsOutPath, t.DefaultPath()), nil
}

func (t *httpConverterTemplate) Prepare() error {
	for _, fn := range t.Info.Iface.Methods {
		t.decodersRequest = append(t.decodersRequest, fn)
		t.encodersRequest = append(t.encodersRequest, fn)
		t.decodersResponse = append(t.decodersResponse, fn)
		t.encodersResponse = append(t.encodersResponse, fn)
	}
	return nil
}

// Render http converters: for exchanges and common.
//		// This file was automatically generated by "microgen" utility.
//		// Please, do not change functions names!
//		package httpconv
//
//		import (
//			bytes "bytes"
//			context "context"
//			json "encoding/json"
//			svc "github.com/devimteam/microgen/example/svc"
//			ioutil "io/ioutil"
//			http "net/http"
//		)
//
//		func DefaultRequestEncoder(_ context.Context, r *http.Request, request interface{}) error {
//			var buf bytes.Buffer
//			if err := json.NewEncoder(&buf).Encode(request); err != nil {
//				return err
//			}
//			r.Body = ioutil.NopCloser(&buf)
//			return nil
//		}
//
//		func DefaultResponseEncoder(_ context.Context, w http.ResponseWriter, response interface{}) error {
//			w.Header().Set("Content-Type", "application/json; charset=utf-8")
//			return json.NewEncoder(w).Encode(response)
//		}
//
//		func DecodeHTTPCountRequest(_ context.Context, r *http.Request) (interface{}, error) {
//			var req svc.CountRequest
//			err := json.NewDecoder(r.Body).Decode(&req)
//			return req, err
//		}
//
//		func DecodeHTTPCountResponse(_ context.Context, r *http.Response) (interface{}, error) {
//			var resp svc.CountResponse
//			err := json.NewDecoder(r.Body).Decode(&resp)
//			return resp, err
//		}
//
//		func EncodeHTTPCountRequest(ctx context.Context, r *http.Request, request interface{}) error {
//			return DefaultRequestEncoder(ctx, r, request)
//		}
//
//		func EncodeHTTPCountResponse(ctx context.Context, w http.ResponseWriter, response interface{}) error {
//			return DefaultResponseEncoder(ctx, w, response)
//		}
//
func (t *httpConverterTemplate) Render() write_strategy.Renderer {
	f := &Statement{}

	if !t.isCommonEncoderRequestExist {
		f.Line().Add(commonEncoderRequest()).Line()
	}
	if !t.isCommonEncoderResponseExist {
		f.Line().Add(commonEncoderResponse()).Line()
	}

	for _, fn := range t.decodersRequest {
		f.Line().Add(t.decodeHttpRequest(fn)).Line()
	}
	for _, fn := range t.decodersResponse {
		f.Line().Add(t.decodeHttpResponse(fn)).Line()
	}
	for _, fn := range t.encodersRequest {
		f.Line().Add(encodeHttpRequest(fn)).Line()
	}
	for _, fn := range t.encodersResponse {
		f.Line().Add(encodeHttpResponse(fn)).Line()
	}

	if t.state == AppendStrat {
		return f
	}

	file := NewFile("httpconv")
	file.PackageComment(FileHeader)
	file.PackageComment(`Please, do not change functions names!`)
	file.Add(f)

	return file
}

// https://github.com/go-kit/kit/blob/master/examples/addsvc/pkg/addtransport/http.go#L201
func commonEncoderRequest() *Statement {
	return Func().Id(commonRequestEncoderName).
		Params(
			Id("_").Qual(PackagePathContext, "Context"),
			Id("r").Op("*").Qual(PackagePathHttp, "Request"),
			Id("request").Interface(),
		).Params(
		Error(),
	).BlockFunc(func(g *Group) {
		g.Var().Id("buf").Qual(PackagePathBytes, "Buffer")
		g.If(
			Err().Op(":=").Qual(PackagePathJson, "NewEncoder").Call(Op("&").Id("buf")).Dot("Encode").Call(Id("request")),
			Err().Op("!=").Nil(),
		).Block(
			Return(Err()),
		)
		g.Id("r").Dot("Body").Op("=").Qual(PackagePathIOUtil, "NopCloser").Call(Op("&").Id("buf"))
		g.Return(Nil())
	})
}

// https://github.com/go-kit/kit/blob/master/examples/addsvc/pkg/addtransport/http.go#L212
func commonEncoderResponse() *Statement {
	return Func().Id(commonResponseEncoderName).
		Params(
			Id("_").Qual(PackagePathContext, "Context"),
			Id("w").Qual(PackagePathHttp, "ResponseWriter"),
			Id("response").Interface(),
		).Params(
		Error(),
	).BlockFunc(func(g *Group) {
		g.Id("w").Dot("Header").Call().Dot("Set").Call(Lit("Content-Type"), Lit("application/json; charset=utf-8"))
		g.Return(
			Qual(PackagePathJson, "NewEncoder").Call(Id("w")).Dot("Encode").Call(Id("response")),
		)
	})
}

//		func DecodeHTTPCountRequest(_ context.Context, r *http.Request) (interface{}, error) {
//			var req svc.CountRequest
//			err := json.NewDecoder(r.Body).Decode(&req)
//			return req, err
//		}
func (t *httpConverterTemplate) decodeHttpRequest(fn *types.Function) *Statement {
	return Func().Id(httpDecodeRequestName(fn)).
		Params(
			Id("_").Qual(PackagePathContext, "Context"),
			Id("r").Op("*").Qual(PackagePathHttp, "Request"),
		).Params(
		Interface(),
		Error(),
	).BlockFunc(func(g *Group) {
		g.Var().Id("req").Qual(t.Info.ServiceImportPath, requestStructName(fn))
		g.Err().Op(":=").Qual(PackagePathJson, "NewDecoder").Call(Id("r").Dot("Body")).Dot("Decode").Call(Op("&").Id("req"))
		g.Return(Op("&").Id("req"), Err())
	})
}

//		func DecodeHTTPCountResponse(_ context.Context, r *http.Response) (interface{}, error) {
//			var resp svc.CountResponse
//			err := json.NewDecoder(r.Body).Decode(&resp)
//			return resp, err
//		}
func (t *httpConverterTemplate) decodeHttpResponse(fn *types.Function) *Statement {
	return Func().Id(httpDecodeResponseName(fn)).
		Params(
			Id("_").Qual(PackagePathContext, "Context"),
			Id("r").Op("*").Qual(PackagePathHttp, "Response"),
		).Params(
		Interface(),
		Error(),
	).
		BlockFunc(func(g *Group) {
			g.Var().Id("resp").Qual(t.Info.ServiceImportPath, responseStructName(fn))
			g.Err().Op(":=").Qual(PackagePathJson, "NewDecoder").Call(Id("r").Dot("Body")).Dot("Decode").Call(Op("&").Id("resp"))
			g.Return(Op("&").Id("resp"), Err())
		})
}

// Render response encoder.
//		func EncodeHTTPCountResponse(ctx context.Context, w http.ResponseWriter, response interface{}) error {
//			return DefaultResponseEncoder(ctx, w, response)
//		}
//
func encodeHttpResponse(fn *types.Function) *Statement {
	return Func().Id(httpEncodeResponseName(fn)).Params(
		Id("ctx").Qual(PackagePathContext, "Context"),
		Id("w").Qual(PackagePathHttp, "ResponseWriter"),
		Id("response").Interface(),
	).Params(
		Error(),
	).Block(
		Return().Id(commonResponseEncoderName).Call(Id("ctx"), Id("w"), Id("response")),
	)
}

// Render request encoder.
//		func EncodeHTTPCountRequest(ctx context.Context, r *http.Request, request interface{}) error {
//			return DefaultRequestEncoder(ctx, r, request)
//		}
//
func encodeHttpRequest(fn *types.Function) *Statement {
	return Func().Id(httpEncodeRequestName(fn)).Params(
		Id("ctx").Qual(PackagePathContext, "Context"),
		Id("r").Op("*").Qual(PackagePathHttp, "Request"),
		Id("request").Interface(),
	).Params(
		Error(),
	).Block(
		Return().Id(commonRequestEncoderName).Call(Id("ctx"), Id("r"), Id("request")),
	)
}

func httpDecodeRequestName(f *types.Function) string {
	return "DecodeHTTP" + util.ToUpperFirst(f.Name) + "Request"
}

func httpEncodeRequestName(f *types.Function) string {
	return "EncodeHTTP" + util.ToUpperFirst(f.Name) + "Request"
}

func httpEncodeResponseName(f *types.Function) string {
	return "EncodeHTTP" + util.ToUpperFirst(f.Name) + "Response"
}

func httpDecodeResponseName(f *types.Function) string {
	return "DecodeHTTP" + util.ToUpperFirst(f.Name) + "Response"
}
