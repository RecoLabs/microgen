package template

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	. "github.com/dave/jennifer/jen"
	"github.com/devimteam/microgen/generator/write_strategy"
	"github.com/devimteam/microgen/util"
	"github.com/vetcher/godecl/types"
)

const (
	GolangProtobufPtypesTimestamp = "github.com/golang/protobuf/ptypes/timestamp"
	JsonbPackage                  = "github.com/sas1024/gorm-jsonb/jsonb"
	GolangProtobufPtypes          = "github.com/golang/protobuf/ptypes"
	GolangProtobufWrappers        = "github.com/golang/protobuf/ptypes/wrappers"
)

type stubGRPCTypeConverterTemplate struct {
	Info                      *GenerationInfo
	alreadyRenderedConverters []string
	state                     WriteStrategyState
}

func NewStubGRPCTypeConverterTemplate(info *GenerationInfo) Template {
	return &stubGRPCTypeConverterTemplate{
		Info: info,
	}
}

func specialTypeConverter(p types.Type) *Statement {
	name := types.TypeName(p)
	imp := types.TypeImport(p)
	// error -> string
	if name != nil && *name == "error" && imp == nil {
		return (&Statement{}).Id("string")
	}
	// time.Time -> timestamp.Timestamp
	if name != nil && *name == "Time" && imp != nil && imp.Package == "time" {
		return (&Statement{}).Op("*").Qual(GolangProtobufPtypesTimestamp, "Timestamp")
	}
	// jsonb.JSONB -> string
	if name != nil && *name == "JSONB" && imp != nil && imp.Package == JsonbPackage {
		return (&Statement{}).Id("string")
	}
	// *string -> *wrappers.StringValue
	if name != nil && *name == "string" && imp == nil && p.TypeOf() == types.T_Pointer {
		return (&Statement{}).Op("*").Qual(GolangProtobufWrappers, "StringValue")
	}
	return nil
}

func converterToProtoBody(field *types.Variable) Code {
	s := &Statement{}
	switch typeToProto(field.Type, 0) {
	case "ErrorToProto":
		s.If(Id(util.ToLowerFirst(field.Name))).Op("==").Nil().Block(
			Return().List(Lit(""), Nil()),
		).Line()
		s.Return().List(Id(util.ToLowerFirst(field.Name)).Dot("Error").Call(), Nil())
	case "ByteListToProto":
		s.Return().List(Id(util.ToLowerFirst(field.Name)), Nil())
	case "TimeTimeToProto":
		s.Return().Qual(GolangProtobufPtypes, "TimestampProto").Call(Id(field.Name))
	case "ListStringToProto", "SliceStringToProto":
		s.Return().List(Id(util.ToLowerFirst(field.Name)), Nil())
	//	if str == "" {
	//		return nil
	//	}
	//	return &wrappers.StringValue{Value: str}
	case "PtrStringToProto":
		s.If(Id(util.ToLowerFirst(field.Name)).Op("==").Nil()).Block(
			Return().List(Nil(), Nil()),
		)
		s.Line().Return().List(Op("&").Qual(GolangProtobufWrappers, "StringValue").Block(Dict{Id("Value"): Op("*").Id(util.ToLowerFirst(field.Name)).Op(",")}), Nil())
	default:
		s.Panic(Lit("function not provided"))
	}
	return s
}

func converterProtoToBody(field *types.Variable) Code {
	s := &Statement{}
	switch protoToType(field.Type, 0) {
	case "ProtoToError":
		s.If().Id("proto" + util.ToUpperFirst(field.Name)).Op("==").Lit("").Block(
			Return().List(Nil(), Nil()),
		).Line()
		s.Return().List(Qual("errors", "New").Call(Id("proto"+util.ToUpperFirst(field.Name))), Nil())
	case "ProtoToByteList":
		s.Return().List(Id("proto"+util.ToUpperFirst(field.Name)), Nil())
	case "ProtoToTimeTime":
		s.Return().Qual(GolangProtobufPtypes, "Timestamp").Call(Id("proto" + util.ToUpperFirst(field.Name)))
	case "ProtoToListString", "ProtoToSliceString":
		s.Return().List(Id("proto"+util.ToUpperFirst(field.Name)), Nil())
	case "ProtoToPtrString":
		s.If(Id("proto" + util.ToUpperFirst(field.Name)).Op("==").Nil()).Block(
			Return().List(Nil(), Nil()),
		)
		s.Line().Return().List(Op("&").Id("proto"+util.ToUpperFirst(field.Name)).Dot("Value"), Nil())
	default:
		s.Panic(Lit("function not provided"))
	}
	return s
}

// Render whole file with protobuf converters.
//
//		// This file was automatically generated by "microgen" utility.
//		package protobuf
//
//		func IntListToProto(positions []int) (protoPositions []int64, convPositionsErr error) {
//			panic("method not provided")
//		}
//
//		func ProtoToIntList(protoPositions []int64) (positions []int, convPositionsErr error) {
//			panic("method not provided")
//		}
//
func (t *stubGRPCTypeConverterTemplate) Render() write_strategy.Renderer {
	f := &Statement{}

	for _, signature := range t.Info.Iface.Methods {
		args := append(removeContextIfFirst(signature.Args), removeErrorIfLast(signature.Results)...)
		for _, field := range args {
			if _, ok := golangTypeToProto("", &field); !ok && !util.IsInStringSlice(typeToProto(field.Type, 0), t.alreadyRenderedConverters) {
				f.Line().Add(t.stubConverterToProto(&field)).Line()
				t.alreadyRenderedConverters = append(t.alreadyRenderedConverters, typeToProto(field.Type, 0))
			}
			if _, ok := protoTypeToGolang("", &field); !ok && !util.IsInStringSlice(protoToType(field.Type, 0), t.alreadyRenderedConverters) {
				f.Line().Add(t.stubConverterProtoTo(&field)).Line()
				t.alreadyRenderedConverters = append(t.alreadyRenderedConverters, protoToType(field.Type, 0))
			}
		}
	}

	if t.state == AppendStrat {
		return f
	}

	file := NewFile("protobuf")
	file.PackageComment(FileHeader)
	file.PackageComment(`It is better for you if you do not change functions names!`)
	file.PackageComment(`This file will never be overwritten.`)
	file.Add(f)

	return file
}

func (stubGRPCTypeConverterTemplate) DefaultPath() string {
	return "./transport/converter/protobuf/type_converters.go"
}

func (t *stubGRPCTypeConverterTemplate) Prepare() error {
	if t.Info.ProtobufPackage == "" {
		return fmt.Errorf("protobuf package is empty")
	}
	return nil
}

func (t *stubGRPCTypeConverterTemplate) ChooseStrategy() (write_strategy.Strategy, error) {
	if err := util.StatFile(t.Info.AbsOutPath, t.DefaultPath()); os.IsNotExist(err) {
		t.state = FileStrat
		return write_strategy.NewCreateFileStrategy(t.Info.AbsOutPath, t.DefaultPath()), nil
	}
	file, err := util.ParseFile(filepath.Join(t.Info.AbsOutPath, t.DefaultPath()))
	if err != nil {
		return nil, err
	}

	for i := range file.Functions {
		t.alreadyRenderedConverters = append(t.alreadyRenderedConverters, file.Functions[i].Name)
	}

	t.state = AppendStrat
	return write_strategy.NewAppendToFileStrategy(t.Info.AbsOutPath, t.DefaultPath()), nil
}

// Render stub method for golang to protobuf converter.
//
//		func IntListToProto(positions []int) (protoPositions []int64, convPositionsErr error) {
//			return
//		}
//
func (t *stubGRPCTypeConverterTemplate) stubConverterToProto(field *types.Variable) *Statement {
	return Func().Id(typeToProto(field.Type, 0)).
		Params(Id(util.ToLowerFirst(field.Name)).Add(fieldType(field.Type, false))).
		Params(Add(t.protoFieldType(field.Type)), Error()).
		Block(converterToProtoBody(field))
}

// Render stub method for protobuf to golang converter.
//
//		func ProtoToIntList(protoPositions []int64) (positions []int, convPositionsErr error) {
//			return
//		}
//
func (t *stubGRPCTypeConverterTemplate) stubConverterProtoTo(field *types.Variable) *Statement {
	return Func().Id(protoToType(field.Type, 0)).
		Params(Id("proto"+util.ToUpperFirst(field.Name)).Add(t.protoFieldType(field.Type))).
		Params(Add(fieldType(field.Type, false)), Error()).
		Block(converterProtoToBody(field))
}

// Render protobuf field type for given func field.
//
//  	*repository.Visit
//
func (t *stubGRPCTypeConverterTemplate) protoFieldType(field types.Type) *Statement {
	c := &Statement{}
	if code := specialTypeConverter(field); code != nil {
		return c.Add(code)
	}
	for field != nil {
		switch f := field.(type) {
		case types.TImport:
			if f.Import != nil {
				c.Qual(t.Info.ProtobufPackage, "")
			}
			field = f.Next
		case types.TName:
			protoType := f.TypeName
			if tmp, ok := goToProtoTypesMap[f.TypeName]; ok {
				protoType = tmp
			}
			c.Id(protoType)
			field = nil
		case types.TArray:
			if f.IsSlice {
				c.Index()
			} else if f.ArrayLen > 0 {
				c.Index(Lit(f.ArrayLen))
			}
			field = f.Next
		case types.TMap:
			return c.Map(t.protoFieldType(f.Key)).Add(t.protoFieldType(f.Value))
		case types.TPointer:
			c.Op(strings.Repeat("*", f.NumberOfPointers))
			field = f.Next
		case types.TInterface:
			mhds := interfaceType(f.Interface)
			return c.Interface(mhds...)
		case types.TEllipsis:
			c.Index()
			field = f.Next
		default:
			return c
		}
	}

	return c
}
