// This file was automatically generated by "microgen 0.8.0alpha" utility.
// Please, do not edit.
package stringsvc

import (
	context "context"
	errors "errors"
	entity "github.com/devimteam/microgen/example/svc/entity"
	endpoint "github.com/go-kit/kit/endpoint"
	opentracing "github.com/go-kit/kit/tracing/opentracing"
	opentracinggo "github.com/opentracing/opentracing-go"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

func AllEndpoints(service StringService, tracer opentracinggo.Tracer) *Endpoints {
	return &Endpoints{
		CountEndpoint:     opentracing.TraceServer(tracer, "Count")(CountEndpoint(service)),
		TestCaseEndpoint:  opentracing.TraceServer(tracer, "TestCase")(TestCaseEndpoint(service)),
		UppercaseEndpoint: opentracing.TraceServer(tracer, "Uppercase")(UppercaseEndpoint(service)),
	}
}

type Endpoints struct {
	UppercaseEndpoint endpoint.Endpoint
	CountEndpoint     endpoint.Endpoint
	TestCaseEndpoint  endpoint.Endpoint
}

func (E *Endpoints) Uppercase(ctx context.Context, stringsMap map[string]string) (ans string, err error) {
	endpointUppercaseRequest := UppercaseRequest{StringsMap: stringsMap}
	endpointUppercaseResponse, err := E.UppercaseEndpoint(ctx, &endpointUppercaseRequest)
	if err != nil {
		if e, ok := status.FromError(err); ok || e.Code() == codes.Internal || e.Code() == codes.Unknown {
			err = errors.New(e.Message())
		}
		return
	}
	return endpointUppercaseResponse.(*UppercaseResponse).Ans, err
}

func (E *Endpoints) Count(ctx context.Context, text string, symbol string) (count int, positions []int, err error) {
	endpointCountRequest := CountRequest{
		Symbol: symbol,
		Text:   text,
	}
	endpointCountResponse, err := E.CountEndpoint(ctx, &endpointCountRequest)
	if err != nil {
		if e, ok := status.FromError(err); ok || e.Code() == codes.Internal || e.Code() == codes.Unknown {
			err = errors.New(e.Message())
		}
		return
	}
	return endpointCountResponse.(*CountResponse).Count, endpointCountResponse.(*CountResponse).Positions, err
}

func (E *Endpoints) TestCase(ctx context.Context, comments []*entity.Comment) (tree map[string]int, err error) {
	endpointTestCaseRequest := TestCaseRequest{Comments: comments}
	endpointTestCaseResponse, err := E.TestCaseEndpoint(ctx, &endpointTestCaseRequest)
	if err != nil {
		if e, ok := status.FromError(err); ok || e.Code() == codes.Internal || e.Code() == codes.Unknown {
			err = errors.New(e.Message())
		}
		return
	}
	return endpointTestCaseResponse.(*TestCaseResponse).Tree, err
}

func UppercaseEndpoint(svc StringService) endpoint.Endpoint {
	return func(ctx context.Context, request interface{}) (interface{}, error) {
		_req := request.(*UppercaseRequest)
		ans, err := svc.Uppercase(ctx, _req.StringsMap)
		return &UppercaseResponse{Ans: ans}, err
	}
}

func CountEndpoint(svc StringService) endpoint.Endpoint {
	return func(ctx context.Context, request interface{}) (interface{}, error) {
		_req := request.(*CountRequest)
		count, positions, err := svc.Count(ctx, _req.Text, _req.Symbol)
		return &CountResponse{
			Count:     count,
			Positions: positions,
		}, err
	}
}

func TestCaseEndpoint(svc StringService) endpoint.Endpoint {
	return func(ctx context.Context, request interface{}) (interface{}, error) {
		_req := request.(*TestCaseRequest)
		tree, err := svc.TestCase(ctx, _req.Comments)
		return &TestCaseResponse{Tree: tree}, err
	}
}
